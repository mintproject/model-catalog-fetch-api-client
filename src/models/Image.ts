// tslint:disable
/**
 * Model Catalog
 * This is the API of the Software Description Ontology at [https://w3id.org/okn/o/sdm](https://w3id.org/okn/o/sdm)
 *
 * The version of the OpenAPI document: v1.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    DataTransformation,
    DataTransformationFromJSON,
    DataTransformationFromJSONTyped,
    DataTransformationToJSON,
    DataTransformationSetup,
    DataTransformationSetupFromJSON,
    DataTransformationSetupFromJSONTyped,
    DataTransformationSetupToJSON,
    DatasetSpecification,
    DatasetSpecificationFromJSON,
    DatasetSpecificationFromJSONTyped,
    DatasetSpecificationToJSON,
    SampleResource,
    SampleResourceFromJSON,
    SampleResourceFromJSONTyped,
    SampleResourceToJSON,
    VariablePresentation,
    VariablePresentationFromJSON,
    VariablePresentationFromJSONTyped,
    VariablePresentationToJSON,
} from './';

/**
 * Description not available
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * Property to indicate dimensionality of the input or output of a dataset specification
     * @type {Array<number>}
     * @memberof Image
     */
    hasDimensionality?: Array<number> | null;
    /**
     * Format followed by a file. For example, txt, nc, etc.
     * @type {Array<string>}
     * @memberof Image
     */
    hasFormat?: Array<string> | null;
    /**
     * Property that indicates the relative path of an input or output with respect to the folder structure of the executable.   For example, let\'s assume we have an input that has to exist in the folder `/datasets` or the executable will not work. This property ensures that this knowledge is captured for a given software component execution.  In this case the property would capture this as follows:  ``` :input_prep a sd:DatasetSpecification . :input_prep rdfs:label \"precipitation file\" . :input_precip sd:pathLocation \"/datasets/\". ```
     * @type {Array<string>}
     * @memberof Image
     */
    pathLocation?: Array<string> | null;
    /**
     * Relates a dataset specification to the data structure definition
     * @type {Array<object>}
     * @memberof Image
     */
    hasFileStructure?: Array<object> | null;
    /**
     * small description
     * @type {Array<string>}
     * @memberof Image
     */
    description?: Array<string> | null;
    /**
     * Property that associates an input/output with their corresponding data transformation.
     * @type {Array<DataTransformation>}
     * @memberof Image
     */
    hasDataTransformation?: Array<DataTransformation> | null;
    /**
     * Property that links an instance of a dataset (or a dataset specification) to the presentation of a variable contained (or expected to be contained) on it.
     * @type {Array<VariablePresentation>}
     * @memberof Image
     */
    hasPresentation?: Array<VariablePresentation> | null;
    /**
     * short description of the resource
     * @type {Array<string>}
     * @memberof Image
     */
    label?: Array<string> | null;
    /**
     * type of the resource
     * @type {Array<string>}
     * @memberof Image
     */
    type?: Array<string> | null;
    /**
     * Property that links a parameter or an input to a fixed value. For example, in a given configuration a parameter with the planting date for a model could be fixed to avoid the user changing it for that region.
     * @type {Array<SampleResource>}
     * @memberof Image
     */
    hasFixedResource?: Array<SampleResource> | null;
    /**
     * Property that links a dataset specification from a model configuration or setup to the output from a target data transformation. This occurs when a data transformation produces several outputs, but only one of them is the one needed for a model
     * @type {Array<DatasetSpecification>}
     * @memberof Image
     */
    isTransformedFrom?: Array<DatasetSpecification> | null;
    /**
     * Property to identify the original source of the information of the annotated resource. It could be a web page, an organization, a person, some experiment notes, etc.
     * @type {Array<object>}
     * @memberof Image
     */
    hadPrimarySource?: Array<object> | null;
    /**
     * Property to link an input/output dataset to the specific data transformation (with URLs
     * @type {Array<DataTransformationSetup>}
     * @memberof Image
     */
    hasDataTransformationSetup?: Array<DataTransformationSetup> | null;
    /**
     * Position of the parameter or input/output in the model configuration. This property is needed to know how to organize the I/O of the component on execution
     * @type {Array<number>}
     * @memberof Image
     */
    position?: Array<number> | null;
    /**
     * identifier
     * @type {string}
     * @memberof Image
     */
    id?: string;
    /**
     * Value associated to the described entity
     * @type {Array<URI | boolean | DateTime | float | integer | string>}
     * @memberof Image
     */
    value?: Array<string> | null;
}

export function ImageFromJSON(json: any): Image {
    return ImageFromJSONTyped(json, false);
}

export function ImageFromJSONTyped(json: any, ignoreDiscriminator: boolean): Image {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'hasDimensionality': !exists(json, 'hasDimensionality') ? undefined : json['hasDimensionality'],
        'hasFormat': !exists(json, 'hasFormat') ? undefined : json['hasFormat'],
        'pathLocation': !exists(json, 'pathLocation') ? undefined : json['pathLocation'],
        'hasFileStructure': !exists(json, 'hasFileStructure') ? undefined : json['hasFileStructure'],
        'description': !exists(json, 'description') ? undefined : json['description'],
        'hasDataTransformation': !exists(json, 'hasDataTransformation') ? undefined : (json['hasDataTransformation'] as Array<any>).map(DataTransformationFromJSON),
        'hasPresentation': !exists(json, 'hasPresentation') ? undefined : (json['hasPresentation'] as Array<any>).map(VariablePresentationFromJSON),
        'label': !exists(json, 'label') ? undefined : json['label'],
        'type': !exists(json, 'type') ? undefined : json['type'],
        'hasFixedResource': !exists(json, 'hasFixedResource') ? undefined : (json['hasFixedResource'] as Array<any>).map(SampleResourceFromJSON),
        'isTransformedFrom': !exists(json, 'isTransformedFrom') ? undefined : (json['isTransformedFrom'] as Array<any>).map(DatasetSpecificationFromJSON),
        'hadPrimarySource': !exists(json, 'hadPrimarySource') ? undefined : json['hadPrimarySource'],
        'hasDataTransformationSetup': !exists(json, 'hasDataTransformationSetup') ? undefined : (json['hasDataTransformationSetup'] as Array<any>).map(DataTransformationSetupFromJSON),
        'position': !exists(json, 'position') ? undefined : json['position'],
        'id': !exists(json, 'id') ? undefined : json['id'],
        'value': !exists(json, 'value') ? undefined : json['value'],
    };
}

export function ImageToJSON(value?: Image): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'hasDimensionality': value.hasDimensionality,
        'hasFormat': value.hasFormat,
        'pathLocation': value.pathLocation,
        'hasFileStructure': value.hasFileStructure,
        'description': value.description,
        'hasDataTransformation': value.hasDataTransformation === undefined ? undefined : (value.hasDataTransformation as Array<any>).map(DataTransformationToJSON),
        'hasPresentation': value.hasPresentation === undefined ? undefined : (value.hasPresentation as Array<any>).map(VariablePresentationToJSON),
        'label': value.label,
        'type': value.type,
        'hasFixedResource': value.hasFixedResource === undefined ? undefined : (value.hasFixedResource as Array<any>).map(SampleResourceToJSON),
        'isTransformedFrom': value.isTransformedFrom === undefined ? undefined : (value.isTransformedFrom as Array<any>).map(DatasetSpecificationToJSON),
        'hadPrimarySource': value.hadPrimarySource,
        'hasDataTransformationSetup': value.hasDataTransformationSetup === undefined ? undefined : (value.hasDataTransformationSetup as Array<any>).map(DataTransformationSetupToJSON),
        'position': value.position,
        'id': value.id,
        'value': value.value,
    };
}


