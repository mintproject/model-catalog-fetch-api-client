// tslint:disable
/**
 * Model Catalog
 * This is the API of the Software Description Ontology at [https://w3id.org/okn/o/sdm](https://w3id.org/okn/o/sdm)
 *
 * The version of the OpenAPI document: v1.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    DataTransformation,
    DataTransformationFromJSON,
    DataTransformationFromJSONTyped,
    DataTransformationToJSON,
    DataTransformationSetup,
    DataTransformationSetupFromJSON,
    DataTransformationSetupFromJSONTyped,
    DataTransformationSetupToJSON,
    SampleResource,
    SampleResourceFromJSON,
    SampleResourceFromJSONTyped,
    SampleResourceToJSON,
    VariablePresentation,
    VariablePresentationFromJSON,
    VariablePresentationFromJSONTyped,
    VariablePresentationToJSON,
} from './';

/**
 * Description not available
 * @export
 * @interface DatasetSpecification
 */
export interface DatasetSpecification {
    /**
     * Property to indicate dimensionality of the input or output of a dataset specification
     * @type {Array<number>}
     * @memberof DatasetSpecification
     */
    hasDimensionality?: Array<number> | null;
    /**
     * Format followed by a file. For example, txt, nc, etc.
     * @type {Array<string>}
     * @memberof DatasetSpecification
     */
    hasFormat?: Array<string> | null;
    /**
     * Property that indicates the relative path of an input or output with respect to the folder structure of the executable.   For example, let\'s assume we have an input that has to exist in the folder `/datasets` or the executable will not work. This property ensures that this knowledge is captured for a given software component execution.  In this case the property would capture this as follows:  ``` :input_prep a sd:DatasetSpecification . :input_prep rdfs:label \"precipitation file\" . :input_precip sd:pathLocation \"/datasets/\". ```
     * @type {Array<string>}
     * @memberof DatasetSpecification
     */
    pathLocation?: Array<string> | null;
    /**
     * Relates a dataset specification to the data structure definition
     * @type {Array<object>}
     * @memberof DatasetSpecification
     */
    hasFileStructure?: Array<object> | null;
    /**
     * small description
     * @type {Array<string>}
     * @memberof DatasetSpecification
     */
    description?: Array<string> | null;
    /**
     * Property that associates an input/output with their corresponding data transformation.
     * @type {Array<DataTransformation>}
     * @memberof DatasetSpecification
     */
    hasDataTransformation?: Array<DataTransformation> | null;
    /**
     * Property that links an instance of a dataset (or a dataset specification) to the presentation of a variable contained (or expected to be contained) on it.
     * @type {Array<VariablePresentation>}
     * @memberof DatasetSpecification
     */
    hasPresentation?: Array<VariablePresentation> | null;
    /**
     * short description of the resource
     * @type {Array<string>}
     * @memberof DatasetSpecification
     */
    label?: Array<string> | null;
    /**
     * type of the resource
     * @type {Array<string>}
     * @memberof DatasetSpecification
     */
    type?: Array<string> | null;
    /**
     * Property that links a parameter or an input to a fixed value. For example, in a given configuration a parameter with the planting date for a model could be fixed to avoid the user changing it for that region.
     * @type {Array<SampleResource>}
     * @memberof DatasetSpecification
     */
    hasFixedResource?: Array<SampleResource> | null;
    /**
     * Property that links a dataset specification from a model configuration or setup to the output from a target data transformation. This occurs when a data transformation produces several outputs, but only one of them is the one needed for a model
     * @type {Array<DatasetSpecification>}
     * @memberof DatasetSpecification
     */
    isTransformedFrom?: Array<DatasetSpecification> | null;
    /**
     * Property to link an input/output dataset to the specific data transformation (with URLs
     * @type {Array<DataTransformationSetup>}
     * @memberof DatasetSpecification
     */
    hasDataTransformationSetup?: Array<DataTransformationSetup> | null;
    /**
     * Position of the parameter or input/output in the model configuration. This property is needed to know how to organize the I/O of the component on execution
     * @type {Array<number>}
     * @memberof DatasetSpecification
     */
    position?: Array<number> | null;
    /**
     * identifier
     * @type {string}
     * @memberof DatasetSpecification
     */
    id?: string;
}

export function DatasetSpecificationFromJSON(json: any): DatasetSpecification {
    return DatasetSpecificationFromJSONTyped(json, false);
}

export function DatasetSpecificationFromJSONTyped(json: any, ignoreDiscriminator: boolean): DatasetSpecification {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'hasDimensionality': !exists(json, 'hasDimensionality') ? undefined : json['hasDimensionality'],
        'hasFormat': !exists(json, 'hasFormat') ? undefined : json['hasFormat'],
        'pathLocation': !exists(json, 'pathLocation') ? undefined : json['pathLocation'],
        'hasFileStructure': !exists(json, 'hasFileStructure') ? undefined : json['hasFileStructure'],
        'description': !exists(json, 'description') ? undefined : json['description'],
        'hasDataTransformation': !exists(json, 'hasDataTransformation') ? undefined : (json['hasDataTransformation'] as Array<any>).map(DataTransformationFromJSON),
        'hasPresentation': !exists(json, 'hasPresentation') ? undefined : (json['hasPresentation'] as Array<any>).map(VariablePresentationFromJSON),
        'label': !exists(json, 'label') ? undefined : json['label'],
        'type': !exists(json, 'type') ? undefined : json['type'],
        'hasFixedResource': !exists(json, 'hasFixedResource') ? undefined : (json['hasFixedResource'] as Array<any>).map(SampleResourceFromJSON),
        'isTransformedFrom': !exists(json, 'isTransformedFrom') ? undefined : (json['isTransformedFrom'] as Array<any>).map(DatasetSpecificationFromJSON),
        'hasDataTransformationSetup': !exists(json, 'hasDataTransformationSetup') ? undefined : (json['hasDataTransformationSetup'] as Array<any>).map(DataTransformationSetupFromJSON),
        'position': !exists(json, 'position') ? undefined : json['position'],
        'id': !exists(json, 'id') ? undefined : json['id'],
    };
}

export function DatasetSpecificationToJSON(value?: DatasetSpecification): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'hasDimensionality': value.hasDimensionality,
        'hasFormat': value.hasFormat,
        'pathLocation': value.pathLocation,
        'hasFileStructure': value.hasFileStructure,
        'description': value.description,
        'hasDataTransformation': value.hasDataTransformation === undefined ? undefined : (value.hasDataTransformation as Array<any>).map(DataTransformationToJSON),
        'hasPresentation': value.hasPresentation === undefined ? undefined : (value.hasPresentation as Array<any>).map(VariablePresentationToJSON),
        'label': value.label,
        'type': value.type,
        'hasFixedResource': value.hasFixedResource === undefined ? undefined : (value.hasFixedResource as Array<any>).map(SampleResourceToJSON),
        'isTransformedFrom': value.isTransformedFrom === undefined ? undefined : (value.isTransformedFrom as Array<any>).map(DatasetSpecificationToJSON),
        'hasDataTransformationSetup': value.hasDataTransformationSetup === undefined ? undefined : (value.hasDataTransformationSetup as Array<any>).map(DataTransformationSetupToJSON),
        'position': value.position,
        'id': value.id,
    };
}


